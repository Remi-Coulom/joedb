Introduction
============

joedb is the "journal-only embedded database". In joedb, a log of all data modifications is stored in permanent storage. A compiler takes a relational database schema as input and produces code in the target programming language for transparently persistent data structures. This way, data can be directly manipulated, without using SQL. The philosophy of joedb is to offer a minimalist low-level mechanism for persistence, without compromising performance.

Context and Motivation
----------------------

The usual approach to writing programs with persistent data stored in a relational database consists in using SQL queries. Most database management systems provide an API that take SQL strings as parameters.

The problem of using an SQL API is that the program has to produce SQL strings at run time. It has a cost in terms of performance, because the SQL string has to be generated by the program, and parsed by the database. Another problem with such SQL string manipulation is the security risk of SQL injection. Also, type and identifier errors will be detected at run time instead of compile-time, which does not fit the philosophy of statically-typed programming languages.

Some weaknesses of SQL APIs can be corrected by encapsulating the SQL string manipulations into some higher-level interfaces such as object-relational mapping systems or data-access objects. These systems improve safety by providing static typing and identifier lookup.

These higher-level interfaces might look much cleaner from the programmer's point of view, but the additional layer of abstraction is costly. For example, it might become necessary to use a loop over objects to update them one by one. One single complex SQL query might have done the job efficiently, but the abstraction forces the programmer to inefficiently generate several queries instead.

The idea of joedb is to overcome these problems by dropping SQL, and all the abstraction layers. Using SQL makes sense as a protocol to connect to a remote database, but is not necessary for an embedded database. All the operations over the relational data can be directly implemented in the target programming language. This produces an architecture that is cleaner, simpler, and offers great opportunities for performance optimization.

Joedb stores data in permanent storage with a journal. Writing a journal is necessary for crash recovery and transactions. And because the journal can contain all the data, it is not necessary to make anything else permanent. In addition to its extreme simplicity, this approach also makes it possible to annotate the history with time stamps and tags, and to re-create any past state of the database.

A journal is a simple representation of the data, but, for many typical operations, it is not a convenient representation. In practice, an application that uses joedb will build in-memory or on-disk tabular structures and indexes to manipulate the data conveniently. The joedb compiler can generate some ready-made data structures for the most usual situations. But the programmer is free to control the data-management code completely, and can implement any data structure or file format that fits a particular usage pattern.

Five-Minute Tutorial
--------------------

In Linux, the following commands should get you ready:

.. code-block:: bash

    sudo apt-get install libsqlite3-dev cmake ninja-build g++ lcov unzip valgrind python-sphinx wget git-core
    git clone git@github.com:Remi-Coulom/joedb.git
    cd joedb/compcmake/
    ./get_gtest.sh
    ./generate.sh
    cd ninja_release
    ninja

This will produce ``joedbi``, the joedb interpreter, and ``joedbc``, the joedb compiler. ``joedbi`` lets you manipulate the database with interactive commands. ``joedbc`` reads a file with joedbi commands that define the database schema, and produce C++ code as output.

All the files for this tutorial are located in the ``doc/source/tutorial`` directory. This directory contains 3 files: ``tutorial.joedbi`` contains the interpreter commands that define the database schema, ``tutorial.cpp`` is the cpp file that manipulates the database, and ``generate.sh`` is a bash script that will compile all the code and run the program.

The contents of these file should be self-explanatory:

``tutorial.joedbi``:

.. literalinclude:: ./tutorial/tutorial.joedbi

``generate.sh``:

.. literalinclude:: ./tutorial/generate.sh
   :language: bash

``tutorial.cpp``:

.. literalinclude:: ./tutorial/tutorial.cpp
   :language: c++

The output of this tutorial should be:

.. literalinclude:: ./tutorial/tutorial.out

Benchmark
---------

The source code for these benchmarks can be found in the joedb/benchmark directory. They were run on a Linux machine with an i7-5930K CPU, and WDC WD20EZRX-00D8PB0 hard drive.

Bulk Insert
~~~~~~~~~~~

First the sqlite3 code:

.. code-block:: c++

  sqlite3_exec(db, "BEGIN TRANSACTION", 0, 0, 0);
  sqlite3_stmt *prepared_statement;
  sqlite3_prepare_v2(db,
                     "INSERT INTO BENCHMARK VALUES('TOTO', ?1)",
                     -1,
                     &prepared_statement,
                     0);

  for (int i = 1; i <= N; i++)
  {
   sqlite3_bind_int64(prepared_statement, 1, i);
   sqlite3_step(prepared_statement);
   sqlite3_reset(prepared_statement);
  }

  sqlite3_exec(db, "END TRANSACTION", 0, 0, 0);

Then, the equivalent joedb code:

.. code-block:: c++

  const std::string s("TOTO");

  for (int i = 1; i <= N; i++)
   db.new_BENCHMARK(s, i);

  db.checkpoint();
  db.commit();

The table below is the minimum of 10 runs, with N = 10,000,000.

+------+--------+---------+
|      | joedb  | sqlite3 |
+------+--------+---------+
| real | 2.803s | 10.266s |
+------+--------+---------+
| user | 0.567s |  7.838s |
+------+--------+---------+
| sys  | 0.200s |  0.319s |
+------+--------+---------+

So, when the database fits in ram, joedb is much faster than sqlite3.

Commit rate
~~~~~~~~~~~

If instead of one big commit at the end, each insert is committed to disk one by one, then the insertion rate is much slower. With N = 100:

+------+--------------+--------------+---------+
|      | joedb (fast) | joedb (slow) | sqlite3 |
+------+--------------+--------------+---------+
| real | 1.549s       | 3.184s       | 5.434s  |
+------+--------------+--------------+---------+
| user | 0.002s       | 0.003s       | 0.006s  |
+------+--------------+--------------+---------+
| sys  | 0.009s       | 0.016s       | 0.021s  |
+------+--------------+--------------+---------+

The fast mode of joedb operates like this:

.. code-block:: c++

  for (int i = 1; i <= N; i++)
  {
   db.new_BENCHMARK(s, i);
   db.checkpoint();
   db.commit();
  }

The fast mode is crash-safe if the underlying system preserves write order.

The slow mode is more paranoid, but twice slower:

.. code-block:: c++

  for (int i = 1; i <= N; i++)
  {
   db.new_BENCHMARK(s, i);
   db.commit();
   db.checkpoint();
   db.commit();
  }

Thanks to its simple append-only file structure, joedb can operate safely with less synchronization operations than sqlite3, which makes it about 1.5 or 3 times faster, depending on synchronization mode.

Note also that joedb does not require a file system: it can also operate over a raw device directly, which might offer additional opportunities for performance optimization.
