Introduction
============

joedb is the "journal-only embedded database", which means that only a log of all data operations is stored on disk. It comes with a compiler that takes a database schema as input and produces C++ code. This code can load the data from the journal file into transparently persistent C++ data structures. This way, data can be efficiently manipulated by native code, without using SQL.

Context and Motivation
----------------------

The usual approach to writing programs with persistent data stored in a relational database consists in using SQL queries. Most database management systems provide an API that take SQL strings as parameters.

The problem of using a SQL API is that the program has to produce SQL strings at run time. It has a cost in terms of performance, because the SQL string has to be generated by the program, and parsed by the database. Also, type and identifier errors will be detected at run time instead of compile-time, which hurts performance and reliability.

Some weaknesses of SQL APIs can be corrected by encapsulating the SQL string manipulations into some higher-level interfaces such as object-relational mapping systems or data-access objects. These systems improve safety by providing static typing and identifier lookup.

These higher-level interfaces might look much cleaner from the programmer's point of view, but the additional layer of abstraction often has some cost, such as abstraction inversion. Abstraction inversion is when the programmer of the application has to re-implement a feature that was hidden by the abstraction. For example, it might become necessary to use a loop over objects to update them one by one. One single complex SQL query might have done the job efficiently, but the abstraction forces the programmer to inefficiently generate several queries instead.

The idea of joedb is to overcome these problems by dropping SQL, and all the abstraction layers. All the operations over the relational data are directly implemented in the target programming language. This produces an architecture that is cleaner, simpler, and offers great opportunities for performance optimization.

In this approach, joedb stores data in permanent storage with an append-only journal. Writing a journal is necessary in order to implement crash recovery and transactions. And because the journal can contain all the data, it is not necessary to make anything else permanent.

A journal is a minimal representation of the database, but, for many typical operations, it is not a convenient representation. In practice, an application that uses joedb will build in-memory or on-disk tabular structures and indexes to manipulate the data conveniently. These convenient data structures are a temporary redundant cache: the only official source of data is the journal. When a joedb database is opened again, the tabular structures are rebuilt from the journal.

Pros and Cons
-------------

Pros:

- There is no SQL string manipulation. This removes the possibility of SQL injection, and the performance cost of SQL interpretation.
- Tables of the relational schema are compiled into classes. This way, errors in tables names, field names or types can be detected at compile time, instead of run time.
- The full data history is stored in joedb. In many applications based on traditional relational database management systems, database designers end up having to create history tables in order to keep data history. Typically, these table are filled by triggers. This is another example of ineffective abstraction inversion. Because any database management system has to write a journal anyway, the revision history should be stored there.
- This approach offers great opportunities for performance optimization. Data is directly stored in C++ data structures. The programmer is free to choose which container best fits each table. So, for instance, a dense table can be kept in a simple C++ std::vector if it is small enough to fit in memory. Huge tables can be stored on disk with `stxxl <http://stxxl.sourceforge.net/>`_ containers. Indexes and triggers are implemented in C++, too. So, in short, the programmer of the application controls the data-management code completely, and can make it as efficient as possible.

Cons:

- It is necessary to read the whole data history when opening a joedb file. This may be slow for large amounts of data. For a server application that is rarely restarted, a slow startup time is not a big problem. But if the application has to be rapidly responsive at startup, and the database is big, then joedb might not be a good choice.
- The joedb file may become very big compared to the size of the data for a database that has a lot of updates and deletes. If necessary, it is possible to compact the journal file and keep only the most recent state. But this operation is not done transparently and may be slow.
- joedb is an embedded database: it does not have the flexibility of the traditional client/server architecture where multiple separately-programmed clients can connect to the same database server. joedb can be used inside a server, but the programmer has to implement the server logic.
- The database schema is statically determined at compile-time, and cannot change during the execution of a compiled application. The schema of a joedb file can be modified by a separate tool, and schema-modifications operations are logged in the joedb file. But such schema modifications cannot occur during the execution of a compiled application.

Five-Minute Tutorial
--------------------

The application can manipulate the data this way

.. code-block:: c++

    #include "tutorial.h"

    int main()
    {
      tutorial::database db("tutorial.joedb");

      tutorial::city Lille = db.insert_city();
      db.update_name(Lille, "Lille");

      tutorial::person remi = db.insert_person("RÃ©mi", tutorial::city::null);

      db.update_city(remi, Lille);

      db.delete_person(remi);

      db.begin_transaction();
      db.end_transaction();

      return 0;
    }

Benchmark
---------
