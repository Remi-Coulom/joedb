Joedb, the Journal-Only Embedded Database
=========================================

Joedb is a minimalist embedded relational database, where data is manipulated directly in the target programming language, without using SQL: a compiler produces native data-manipulation code from the database schema.

In joedb, the journal of all modifications is stored to disk. This way, the whole data history is remembered, and it is possible to re-create any past state of the database. It is also a way to make the system extremely simple, and fast.

Context and Motivation
----------------------

The usual approach to writing programs with persistent data stored in a relational database consists in using SQL queries. Most database management systems provide an API that takes SQL strings as parameters.

The problem of using an SQL API is that the program has to produce SQL strings at run time. It has a cost in terms of performance, because the SQL string has to be generated by the program, and parsed by the database. Another problem with such SQL string manipulation is the security risk of SQL injection. Also, type and identifier errors will be detected at run time instead of compile-time, which does not fit the philosophy of statically-typed programming languages.

Some weaknesses of SQL APIs can be corrected by encapsulating the SQL string manipulations into some higher-level interfaces such as object-relational mapping systems or data-access objects. These systems improve safety by providing static typing and identifier lookup.

These higher-level interfaces might look much cleaner from the programmer's point of view, but the additional layer of abstraction is costly. For example, it might become necessary to use a loop over objects to update them one by one. One single complex SQL query might have done the job efficiently, but the abstraction forces the programmer to inefficiently generate several queries instead.

The idea of joedb is to overcome these problems by dropping SQL, and all the abstraction layers. Using SQL makes sense as a protocol to connect to a remote database, but is not necessary for an embedded database. All the operations over the relational data can be directly implemented in the target programming language. This produces an architecture that is cleaner, simpler, and offers great opportunities for performance optimization.

Joedb stores data in permanent storage with a journal. Writing a journal is necessary for crash recovery and transactions. And because the journal can contain all the data, it is not necessary to make anything else permanent. In addition to its extreme simplicity, this approach also makes it possible to annotate the history with time stamps and tags, and to re-create any past state of the database.

A journal is a simple representation of the data, but, for many typical operations, it is not a convenient representation. In practice, an application that uses joedb will build in-memory or on-disk tabular structures and indexes to manipulate the data conveniently. The joedb compiler can generate some ready-made data structures for the most usual situations. But the programmer is free to control the data-management code completely, and can implement any data structure or file format that fits a particular usage pattern.

Five-Minute Tutorial
--------------------

The source code of joedb is available from `GitHub <https://github.com/Remi-Coulom/joedb>`_.

In Linux, the following commands should get you ready:

.. code-block:: bash

    sudo apt-get install libsqlite3-dev cmake ninja-build g++ lcov unzip valgrind python-sphinx wget git-core libboost-all-dev
    git clone https://github.com/Remi-Coulom/joedb.git
    cd joedb/compcmake/
    ./get_gtest.sh
    ./generate.sh
    cd ninja_release
    ninja

This will produce ``joedbi``, the joedb interpreter, and ``joedbc``, the joedb compiler. ``joedbi`` lets you manipulate the database with interactive commands. ``joedbc`` reads a file with joedbi commands that define the database schema, and produce C++ code as output.

All the files for this tutorial are located in the ``doc/source/tutorial`` directory. This directory contains 4 files: ``tutorial.joedbi`` contains the interpreter commands that define the database schema, ``tutorial.joedbc`` defines compiler options, ``tutorial_main.cpp`` is the cpp file that manipulates the database, and ``generate.sh`` is a bash script that will compile all the code and run the program.

The contents of these files should be self-explanatory:

``tutorial.joedbi``:

.. literalinclude:: ./tutorial/tutorial.joedbi

``tutorial.joedbc``:

.. literalinclude:: ./tutorial/tutorial.joedbc

``generate.sh``:

.. literalinclude:: ./tutorial/generate.sh
   :language: bash

``tutorial_main.cpp``:

.. literalinclude:: ./tutorial/tutorial_main.cpp
   :language: c++

The output of this tutorial should be:

.. literalinclude:: ./tutorial/tutorial.out

Benchmark
---------

The source code for these benchmarks can be found in the joedb/benchmark directory. They were run on a Linux machine with an i7-5930K CPU, and WDC WD20EZRX-00D8PB0 hard drive.

Bulk Insert
~~~~~~~~~~~

The table below is the minimum of 10 runs, with N = 10,000,000 rows inserted.

+------+---------+--------+
|      | sqlite3 | joedb  |
+======+=========+========+
| real | 10.266s | 2.803s |
+------+---------+--------+
| user |  7.838s | 0.567s |
+------+---------+--------+
| sys  |  0.319s | 0.200s |
+------+---------+--------+

First the sqlite3 code:

.. code-block:: c++

  sqlite3_exec(db, "BEGIN TRANSACTION", 0, 0, 0);
  sqlite3_stmt *prepared_statement;
  sqlite3_prepare_v2(db,
                     "INSERT INTO BENCHMARK VALUES('TOTO', ?1)",
                     -1,
                     &prepared_statement,
                     0);

  for (int i = 1; i <= N; i++)
  {
   sqlite3_bind_int64(prepared_statement, 1, i);
   sqlite3_step(prepared_statement);
   sqlite3_reset(prepared_statement);
  }

  sqlite3_exec(db, "END TRANSACTION", 0, 0, 0);

Then, the equivalent joedb code:

.. code-block:: c++

  const std::string s("TOTO");

  for (int i = 1; i <= N; i++)
   db.new_BENCHMARK(s, i);

  db.checkpoint();
  db.commit();

The joedb code not only uses 13 times less CPU time, it is also shorter, much more readable, and has many less potential run-time errors.

Commit Rate
~~~~~~~~~~~

Instead of one big commit at the end, each insert is now committed to disk one by one. With N = 100:

+------+---------+--------------+--------------+
|      | sqlite3 | joedb (slow) | joedb (fast) |
+======+=========+==============+==============+
| real | 5.434s  | 3.184s       | 1.549s       |
+------+---------+--------------+--------------+
| user | 0.006s  | 0.003s       | 0.002s       |
+------+---------+--------------+--------------+
| sys  | 0.021s  | 0.016s       | 0.009s       |
+------+---------+--------------+--------------+

The fast mode of joedb is crash-safe if the underlying system preserves write order:

.. code-block:: c++

  for (int i = 1; i <= N; i++)
  {
   db.new_BENCHMARK(s, i);
   db.checkpoint();
   db.commit();
  }

The slow mode is more paranoid, but twice slower:

.. code-block:: c++

  for (int i = 1; i <= N; i++)
  {
   db.new_BENCHMARK(s, i);
   db.commit();
   db.checkpoint();
   db.commit();
  }

Thanks to its simple append-only file structure, joedb can operate safely with less synchronization operations than sqlite3, which makes it about 1.5 or 3 times faster, depending on synchronization mode.

Note also that joedb does not require a file system: it can also operate over a raw device directly, which might offer additional opportunities for performance optimization.
