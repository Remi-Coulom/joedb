Introduction
============

joedb is the "journal-only embedded database". In joedb, only a log of all data modifications is stored in permanent storage. A compiler takes a relational database schema as input and produces code in the target programming language for transparently persistent data structures. This way, data can be directly manipulated, without using SQL. The philosophy of joedb is to offer a minimalist low-level mechanism for persistence, without compromising performance.

Context and Motivation
----------------------

The usual approach to writing programs with persistent data stored in a relational database consists in using SQL queries. Most database management systems provide an API that take SQL strings as parameters.

The problem of using an SQL API is that the program has to produce SQL strings at run time. It has a cost in terms of performance, because the SQL string has to be generated by the program, and parsed by the database. Another problem with such SQL string manipulation is the security risk of `SQL Injection <http://en.wikipedia.org/wiki/SQL_injection>`_. Also, type and identifier errors will be detected at run time instead of compile-time, which does not fit the philosophy of statically-typed programming languages.

Some weaknesses of SQL APIs can be corrected by encapsulating the SQL string manipulations into some higher-level interfaces such as object-relational mapping systems or data-access objects. These systems improve safety by providing static typing and identifier lookup.

These higher-level interfaces might look much cleaner from the programmer's point of view, but the additional layer of abstraction is costly. For example, it might become necessary to use a loop over objects to update them one by one. One single complex SQL query might have done the job efficiently, but the abstraction forces the programmer to inefficiently generate several queries instead.

The idea of joedb is to overcome these problems by dropping SQL, and all the abstraction layers. All the operations over the relational data are directly implemented in the target programming language. This produces an architecture that is cleaner, simpler, and offers great opportunities for performance optimization.

Joedb stores data in permanent storage with a journal. Writing a journal is necessary for crash recovery and transactions. And because the journal can contain all the data, it is not necessary to make anything else permanent. In addition to its extreme simplicity, this approach also makes it possible to annotate the history with time stamps and tags, and to re-create any past state of the database.

A journal is a simple representation of the data, but, for many typical operations, it is not a convenient representation. In practice, an application that uses joedb will build in-memory or on-disk tabular structures and indexes to manipulate the data conveniently. The joedb compiler can generate some ready-made data structures for the most usual situations. But the programmer is free to control the data-management code completely, and can implement any data structure or file format that fits a particular usage pattern.

In short, joedb fixes the ugliness of having to call a high-level dynamic query language from a statically-typed programming language. This approach produces programs that are simpler, cleaner, and faster.

Five-Minute Tutorial
--------------------

.. literalinclude:: ./tutorial/tutorial.joedbi

The application can manipulate the data this way

.. literalinclude:: ./tutorial/tutorial.cpp
   :language: c++

Benchmark
---------
