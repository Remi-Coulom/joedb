1: make something work fast:
 - simple interactive interpreter
 - write binary log (store version number)
 - load binary log
 - simple compiler:
   * class database
   * class person
     {
      friend class database;
      private:
       record_id_t id;
       person(record_id_t id): id(id) {} // only the database can construct
      public:
       record_id_t get_record_id() const {return id;}
     };
   * struct person_data
     {
      std::string name;
      db_namespace::city city;
     }
   * city Lille = db.insert_city();
     db.update_name(Lille, "Lille");
   * person remi = db.insert_person("RÃ©mi", city::null);
   * db.update_city(remi, Lille);
   * db.delete(remi);
   * db.begin_transaction();
   * db.end_transaction();
   * transactions:
     - write "begin" and "commit" operations to journal
     - no rollback possible from within the code
     - rollback only in case of failure (crash, ...) at load time
  - core compiler options:
   * namespace as parameter
   * mutex protection as option
   * triggers: C++ code: after/before insert/update/delete
  - utility compilation (with triggers): vector cache for a table.

2: make it good:
 - unit testing (gtest, cmake integration)
 - documentation
 - compact dump (insert with data instead of field-by-field updates)
 - Compiler utilities:
   - table storage:
     - any stl container (vector, deque, map, unordered_map)
     - file (maybe, for big tables): make on-disk C++ containers
     - easy loop over database records (for (auto person: db.persons))
   - index, unique constraints (use triggers)
   - referential integrity (use triggers)
   - queries
   - incrementally-updated group-by queries (OLAP, hypercube, ...)
 - more data types: date, ip, vector<int>, ...
 - option to have rapidly undo-able history
 - schema option: reuse deleted ids (implement with a linked list of free recs)
 - don't store only table: also store variables. This can be done with a "single-row" table option. http://stackoverflow.com/questions/2300356/using-a-single-row-configuration-table-in-sql-server-database-bad-idea
 - a table can be made "read-only" as an option

Keywords:
 - transparent persistence
 - append-only file
 - embedded database

References:
 Database with history/revisions:
 - http://stackoverflow.com/questions/2724187/where-are-all-the-native-revisioned-databases
 - http://stackoverflow.com/questions/39281/database-design-for-revisions
 - http://stackoverflow.com/questions/9852703/store-all-data-changes-with-every-details-like-stackoverflow
 - http://www.oracle.com/technetwork/issue-archive/2008/08-jul/o48totalrecall-092147.html
 - http://stackoverflow.com/questions/12321200/database-row-snapshots-revisions
 - http://stackoverflow.com/questions/750782/database-design-for-text-revisions
 - https://github.com/DanielWaterworth/AODBM
 - http://www.zodb.org/en/latest/
 - http://oldblog.antirez.com/post/redis-persistence-demystified.html
 - http://stackoverflow.com/questions/9484714/how-to-store-datas-change-history
 - http://ayende.com/blog/162792/worlds-smallest-no-sql-database-persistent-transaction-logs

 SQLite:
 - http://www.sqlite.org/

 Berkeley DB:
 - http://en.wikipedia.org/wiki/Berkeley_DB

 Relational Template Library
 - http://sourceforge.net/projects/rel-temp-lib/

 POST++:
 - http://www.garret.ru/post/readme.htm

 On-disk containers:
 - http://stackoverflow.com/questions/149488/disk-backed-stl-container-classes
 - http://stxxl.sourceforge.net/

 Object-Relational Mapping (ORM)
 - http://www.codesynthesis.com/products/odb/
 - http://www.webtoolkit.eu/wt/doc/tutorial/dbo/tutorial.html
 - http://sourceforge.net/projects/litesql/

 Active record pattern:
 - http://en.wikipedia.org/wiki/Active_record_pattern

 Serialization
 - http://www.boost.org/doc/libs/1_56_0/libs/serialization/doc/index.html

 C++ queries
 - http://www.drdobbs.com/cpp/linq-like-list-manipulation-in-c/240166882
