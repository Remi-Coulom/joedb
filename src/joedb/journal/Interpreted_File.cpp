#include "joedb/journal/Interpreted_File.h"

namespace joedb
{
 ////////////////////////////////////////////////////////////////////////////
 void Abstract_Interpreted_File::read_data()
 ////////////////////////////////////////////////////////////////////////////
 {
  interpreter.main_loop(ios, null_stream);
  ios.clear();
  ios.seekp(0, std::ios::end);

  if (!interpreter.is_last_line_empty())
  {
   throw joedb::Exception
   (
    "Interpreted_File: last line of joedbi file must be empty"
   );
  }

  journal.soft_checkpoint();
 }

 ////////////////////////////////////////////////////////////////////////////
 Abstract_Interpreted_File::Abstract_Interpreted_File(Abstract_File &file):
 ////////////////////////////////////////////////////////////////////////////
  Abstract_File(file.get_mode()),
  filebuf(file),
  ios(&filebuf),
  journal(memory_file),
  reading_multiplexer{db, journal},
  interpreter(db, reading_multiplexer, Record_Id::null),
  interpreter_writable(ios, db),
  writing_multiplexer{interpreter_writable, db},
  null_file(Open_Mode::create_new),
  null_filebuf(null_file),
  null_stream(&null_filebuf)
 {
  interpreter.set_echo(false);
  interpreter.set_rethrow(true);
  read_data();
 }

 ////////////////////////////////////////////////////////////////////////////
 int64_t Abstract_Interpreted_File::get_size() const
 ////////////////////////////////////////////////////////////////////////////
 {
  return memory_file.get_size();
 }

 ////////////////////////////////////////////////////////////////////////////
 size_t Abstract_Interpreted_File::pread
 ////////////////////////////////////////////////////////////////////////////
 (
  char *data,
  size_t size,
  int64_t offset
 ) const
 {
  return memory_file.pread(data, size, offset);
 }

 ////////////////////////////////////////////////////////////////////////////
 void Abstract_Interpreted_File::pwrite
 ////////////////////////////////////////////////////////////////////////////
 (
  const char *buffer,
  size_t size,
  int64_t offset
 )
 {
  memory_file.pwrite(buffer, size, offset);

  if (offset < Header::ssize && journal.pull())
  {
   journal.play_until_checkpoint(writing_multiplexer);
   ios.flush();
   ios.seekg(0, std::ios::end);
  }
 }

 ////////////////////////////////////////////////////////////////////////////
 void Abstract_Interpreted_File::sync()
 ////////////////////////////////////////////////////////////////////////////
 {
  filebuf.get_file().sync();
 }

 ////////////////////////////////////////////////////////////////////////////
 void Abstract_Interpreted_File::shared_lock(int64_t start, int64_t size)
 ////////////////////////////////////////////////////////////////////////////
 {
  filebuf.get_file().shared_lock(start, size);
  read_data();
 }

 ////////////////////////////////////////////////////////////////////////////
 void Abstract_Interpreted_File::exclusive_lock(int64_t start, int64_t size)
 ////////////////////////////////////////////////////////////////////////////
 {
  filebuf.get_file().exclusive_lock(start, size);
  read_data();
 }

 ////////////////////////////////////////////////////////////////////////////
 void Abstract_Interpreted_File::unlock(int64_t start, int64_t size) noexcept
 ////////////////////////////////////////////////////////////////////////////
 {
  filebuf.get_file().unlock(start, size);
 }
}
