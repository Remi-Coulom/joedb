#ifndef joedb_Memory_File_declared
#define joedb_Memory_File_declared

#include "joedb/journal/Generic_File.h"

#include <algorithm>

namespace joedb
{
 ////////////////////////////////////////////////////////////////////////////
 class Plain_Memory_File_Data
 ////////////////////////////////////////////////////////////////////////////
 {
  protected:
   std::vector<char> data;
 };

 template<typename Parent>
 ////////////////////////////////////////////////////////////////////////////
 class Memory_File_Template: public Parent, public Generic_File
 ////////////////////////////////////////////////////////////////////////////
 {
  protected:
   size_t current;

   //////////////////////////////////////////////////////////////////////////
   int64_t raw_get_size() const override
   //////////////////////////////////////////////////////////////////////////
   {
    return int64_t(Parent::data.size());
   }

   //////////////////////////////////////////////////////////////////////////
   size_t raw_read(char *buffer, size_t size) override
   //////////////////////////////////////////////////////////////////////////
   {
    const size_t max_size = Parent::data.size() - current;
    const size_t n = std::min(size, max_size);
    std::copy_n(Parent::data.data() + current, n, buffer);
    current += n;
    return n;
   }

   //////////////////////////////////////////////////////////////////////////
   size_t raw_pread(char *buffer, size_t size, int64_t offset) override
   //////////////////////////////////////////////////////////////////////////
   {
    const size_t max_size = Parent::data.size() - offset;
    const size_t n = std::min(size, max_size);
    std::copy_n(Parent::data.data() + offset, n, buffer);
    return n;
   }

   //////////////////////////////////////////////////////////////////////////
   void raw_write(const char *buffer, size_t size) override
   //////////////////////////////////////////////////////////////////////////
   {
    const size_t end = current + size;
    if (end > Parent::data.size())
     Parent::data.resize(end);
    std::copy_n(buffer, size, &Parent::data[current]);
    current += size;
   }

   //////////////////////////////////////////////////////////////////////////
   void raw_pwrite(const char *buffer, size_t size, int64_t offset) override
   //////////////////////////////////////////////////////////////////////////
   {
    const size_t end = offset + size;
    if (end > Parent::data.size())
     Parent::data.resize(end);
    std::copy_n(buffer, size, &Parent::data[offset]);
   }

   //////////////////////////////////////////////////////////////////////////
   void raw_seek(int64_t offset) override
   //////////////////////////////////////////////////////////////////////////
   {
    if (offset >= 0 && offset <= raw_get_size())
     current = size_t(offset);
    else
     throw Exception("seek out of range");
   }

  public:
   //////////////////////////////////////////////////////////////////////////
   Memory_File_Template():
   //////////////////////////////////////////////////////////////////////////
    Generic_File(Open_Mode::create_new),
    current(0)
   {
   }

   //////////////////////////////////////////////////////////////////////////
   Memory_File_Template(std::vector<char> &data):
   //////////////////////////////////////////////////////////////////////////
    Parent(data),
    Generic_File(Open_Mode::shared_write),
    current(0)
   {
   }

   //////////////////////////////////////////////////////////////////////////
   const std::vector<char> &get_data() const
   //////////////////////////////////////////////////////////////////////////
   {
    return Parent::data;
   }

   //////////////////////////////////////////////////////////////////////////
   ~Memory_File_Template() override
   //////////////////////////////////////////////////////////////////////////
   {
    destructor_flush();
   }
 };

 using Memory_File = Memory_File_Template<Plain_Memory_File_Data>;
}

#endif
